#!/usr/bin/env python3
"""
Generate API documentation HTML from .NET XML documentation files.
This script reads XML doc files generated by the C# compiler and produces
HTML files that match the existing Burner CLI documentation style.
"""

import xml.etree.ElementTree as ET
import os
import sys
import re
from pathlib import Path
from dataclasses import dataclass, field
from typing import Optional


@dataclass
class Parameter:
    name: str
    description: str


@dataclass
class Method:
    name: str
    signature: str
    summary: str
    parameters: list[Parameter] = field(default_factory=list)
    returns: str = ""


@dataclass
class Property:
    name: str
    type_name: str
    summary: str


@dataclass
class TypeDoc:
    name: str
    namespace: str
    summary: str
    kind: str  # "class", "interface", "enum"
    methods: list[Method] = field(default_factory=list)
    properties: list[Property] = field(default_factory=list)
    constructors: list[Method] = field(default_factory=list)


def parse_xml_docs(xml_path: str) -> dict[str, TypeDoc]:
    """Parse a .NET XML documentation file and extract type information."""
    tree = ET.parse(xml_path)
    root = tree.getroot()
    
    types: dict[str, TypeDoc] = {}
    members = root.find("members")
    
    if members is None:
        return types
    
    # First pass: collect all types
    for member in members.findall("member"):
        name = member.get("name", "")
        
        if name.startswith("T:"):
            # This is a type
            full_name = name[2:]  # Remove "T:" prefix
            parts = full_name.rsplit(".", 1)
            namespace = parts[0] if len(parts) > 1 else ""
            type_name = parts[-1]
            
            summary_elem = member.find("summary")
            summary = get_text(summary_elem)
            
            types[full_name] = TypeDoc(
                name=type_name,
                namespace=namespace,
                summary=summary,
                kind="class"
            )
    
    # Second pass: collect methods and properties
    for member in members.findall("member"):
        name = member.get("name", "")
        
        if name.startswith("M:"):
            # This is a method or constructor
            parse_method(name[2:], member, types)
        elif name.startswith("P:"):
            # This is a property
            parse_property(name[2:], member, types)
    
    return types


def parse_method(full_name: str, member: ET.Element, types: dict[str, TypeDoc]):
    """Parse a method and add it to the appropriate type."""
    # Handle method with or without parameters
    # Format: Namespace.TypeName.MethodName or Namespace.TypeName.MethodName(params)
    
    # Find where parameters start (if any)
    paren_pos = full_name.find("(")
    if paren_pos >= 0:
        method_full = full_name[:paren_pos]
        params_str = full_name[paren_pos:]
    else:
        method_full = full_name
        params_str = "()"
    
    # Split into type and method name
    parts = method_full.rsplit(".", 1)
    if len(parts) != 2:
        return
    
    type_name = parts[0]
    method_name = parts[1]
    
    if type_name not in types:
        return
    
    summary_elem = member.find("summary")
    summary = get_text(summary_elem)
    
    # Skip inherited docs without content
    inheritdoc = member.find("inheritdoc")
    if inheritdoc is not None and not summary:
        return
    
    # Parse parameters
    parameters = []
    for param in member.findall("param"):
        param_name = param.get("name", "")
        param_desc = get_text(param)
        parameters.append(Parameter(name=param_name, description=param_desc))
    
    # Parse return value
    returns_elem = member.find("returns")
    returns = get_text(returns_elem)
    
    # Build signature
    signature = build_signature(method_name, params_str, parameters)
    
    method = Method(
        name=method_name,
        signature=signature,
        summary=summary,
        parameters=parameters,
        returns=returns
    )
    
    if method_name == "#ctor":
        method.name = types[type_name].name
        method.signature = build_signature(types[type_name].name, params_str, parameters)
        types[type_name].constructors.append(method)
    else:
        types[type_name].methods.append(method)


def parse_property(full_name: str, member: ET.Element, types: dict[str, TypeDoc]):
    """Parse a property and add it to the appropriate type."""
    parts = full_name.rsplit(".", 1)
    if len(parts) != 2:
        return
    
    type_name, prop_name = parts
    
    if type_name not in types:
        return
    
    summary_elem = member.find("summary")
    summary = get_text(summary_elem)
    
    prop = Property(
        name=prop_name,
        type_name="",  # We don't have type info in XML docs
        summary=summary
    )
    
    types[type_name].properties.append(prop)


def build_signature(method_name: str, params_str: str, parameters: list[Parameter]) -> str:
    """Build a human-readable method signature."""
    if params_str == "()" or not params_str:
        return f"{method_name}()"
    
    # Simplify parameter types
    params_str = params_str.strip("()")
    params = []
    
    # Handle nested generics properly
    depth = 0
    current = ""
    for char in params_str:
        if char == '{':
            depth += 1
            current += '<'
        elif char == '}':
            depth -= 1
            current += '>'
        elif char == ',' and depth == 0:
            params.append(current.strip())
            current = ""
        else:
            current += char
    if current.strip():
        params.append(current.strip())
    
    param_parts = []
    for i, param in enumerate(params):
        # Simplify common types
        param = re.sub(r"System\.", "", param)
        param = re.sub(r"Burner\.Models\.", "", param)
        param = re.sub(r"Burner\.Services\.", "", param)
        param = re.sub(r"Nullable<(.+)>", r"\1?", param)
        # Get parameter name if available
        if i < len(parameters):
            param_parts.append(f"{param} {parameters[i].name}")
        else:
            param_parts.append(param)
    
    return f"{method_name}({', '.join(param_parts)})"


def get_text(elem: Optional[ET.Element]) -> str:
    """Extract and clean text from an XML element."""
    if elem is None:
        return ""
    
    text = "".join(elem.itertext())
    # Clean up whitespace
    text = re.sub(r"\s+", " ", text)
    return text.strip()


def generate_html(types: dict[str, TypeDoc], category: str, output_path: str, template_path: str):
    """Generate HTML documentation for a category of types."""
    
    # Filter types by namespace
    if category == "services":
        filtered = {k: v for k, v in types.items() if "Services" in k}
        title = "Services API Reference"
        description = "Core service classes that power Burner CLI functionality."
    elif category == "models":
        filtered = {k: v for k, v in types.items() if "Models" in k}
        title = "Models API Reference"
        description = "Data models and configuration classes."
    elif category == "commands":
        filtered = {k: v for k, v in types.items() if "Commands" in k}
        title = "Commands API Reference"
        description = "CLI command implementations."
    else:
        filtered = types
        title = "API Reference"
        description = ""
    
    # Read template
    with open(template_path, 'r', encoding='utf-8') as f:
        template = f.read()
    
    # Generate content
    content_parts = []
    content_parts.append(f"<h1>{title}</h1>")
    content_parts.append(f"<p>{description}</p>")
    content_parts.append("")
    content_parts.append("<!-- AUTO-GENERATED FROM SOURCE CODE - DO NOT EDIT MANUALLY -->")
    content_parts.append(f"<!-- Generated from XML documentation comments -->")
    content_parts.append("")
    
    # Sort by name for consistent output
    for full_name in sorted(filtered.keys()):
        type_doc = filtered[full_name]
        content_parts.append(generate_type_html(type_doc))
    
    # Add source file links
    if category == "services":
        content_parts.append('<h2>Source Files</h2>')
        content_parts.append('<ul>')
        content_parts.append('    <li><a href="https://github.com/nor0x/burner/blob/main/Burner/Services/ProjectService.cs">Burner/Services/ProjectService.cs</a></li>')
        content_parts.append('    <li><a href="https://github.com/nor0x/burner/blob/main/Burner/Services/TemplateService.cs">Burner/Services/TemplateService.cs</a></li>')
        content_parts.append('</ul>')
    elif category == "models":
        content_parts.append('<h2>Source Files</h2>')
        content_parts.append('<ul>')
        content_parts.append('    <li><a href="https://github.com/nor0x/burner/blob/main/Burner/Models/BurnerConfig.cs">Burner/Models/BurnerConfig.cs</a></li>')
        content_parts.append('    <li><a href="https://github.com/nor0x/burner/blob/main/Burner/Models/BurnerProject.cs">Burner/Models/BurnerProject.cs</a></li>')
        content_parts.append('</ul>')
    elif category == "commands":
        content_parts.append('<h2>Source Files</h2>')
        content_parts.append('<ul>')
        content_parts.append('    <li><a href="https://github.com/nor0x/burner/blob/main/Burner/Commands/">Burner/Commands/</a></li>')
        content_parts.append('</ul>')
    
    # Insert content into template
    content = "\n".join(content_parts)
    
    # Find the main content area and replace it
    # Look for the pattern between <main class="main-content"> and </main>
    pattern = r'(<main class="main-content">).*?(</main>)'
    replacement = rf'\1\n            {content}\n        \2'
    output = re.sub(pattern, replacement, template, flags=re.DOTALL)
    
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(output)
    
    print(f"Generated {output_path} ({len(filtered)} types)")


def generate_type_html(type_doc: TypeDoc) -> str:
    """Generate HTML for a single type."""
    parts = []
    
    parts.append(f'<div class="api-class">')
    parts.append(f'    <div class="api-class-header">')
    parts.append(f'        <div class="api-class-name">{escape_html(type_doc.name)}</div>')
    parts.append(f'        <div class="api-class-namespace">{escape_html(type_doc.namespace)}</div>')
    parts.append(f'    </div>')
    parts.append(f'    <div class="api-class-body">')
    
    if type_doc.summary:
        parts.append(f'        <p>{escape_html(type_doc.summary)}</p>')
    
    # Properties
    if type_doc.properties:
        parts.append(f'        <h4>Properties</h4>')
        for prop in type_doc.properties:
            parts.append(f'        <div class="api-method">')
            parts.append(f'            <code class="api-method-sig">{escape_html(prop.name)}</code>')
            if prop.summary:
                parts.append(f'            <p class="api-method-desc">{escape_html(prop.summary)}</p>')
            parts.append(f'        </div>')
    
    # Constructors
    if type_doc.constructors:
        parts.append(f'        <h4>Constructor</h4>')
        for ctor in type_doc.constructors:
            parts.append(f'        <div class="api-method">')
            parts.append(f'            <code class="api-method-sig">{escape_html(ctor.signature)}</code>')
            if ctor.summary:
                parts.append(f'            <p class="api-method-desc">{escape_html(ctor.summary)}</p>')
            parts.append(f'        </div>')
    
    # Methods
    if type_doc.methods:
        parts.append(f'        <h4>Methods</h4>')
        for method in type_doc.methods:
            parts.append(f'        <div class="api-method">')
            parts.append(f'            <code class="api-method-sig">{escape_html(method.signature)}</code>')
            desc = method.summary
            if method.returns:
                desc += f" Returns: {method.returns}"
            if desc:
                parts.append(f'            <p class="api-method-desc">{escape_html(desc)}</p>')
            parts.append(f'        </div>')
    
    parts.append(f'    </div>')
    parts.append(f'</div>')
    parts.append('')
    
    return '\n'.join(parts)


def escape_html(text: str) -> str:
    """Escape HTML special characters."""
    return (text
            .replace("&", "&amp;")
            .replace("<", "&lt;")
            .replace(">", "&gt;")
            .replace('"', "&quot;"))


def main():
    if len(sys.argv) < 2:
        print("Usage: generate_api_docs.py <xml_docs_path> [website_path]")
        sys.exit(1)
    
    xml_path = sys.argv[1]
    website_path = sys.argv[2] if len(sys.argv) > 2 else "Website/docs/api"
    
    if not os.path.exists(xml_path):
        print(f"Error: XML documentation file not found: {xml_path}")
        sys.exit(1)
    
    print(f"Parsing XML documentation from {xml_path}...")
    types = parse_xml_docs(xml_path)
    print(f"Found {len(types)} types")
    
    for full_name, type_doc in types.items():
        method_count = len(type_doc.methods) + len(type_doc.constructors)
        prop_count = len(type_doc.properties)
        if method_count > 0 or prop_count > 0:
            print(f"  {type_doc.name}: {method_count} methods, {prop_count} properties")
    
    # Use existing HTML files as templates
    api_path = Path(website_path)
    
    for category in ["services", "models", "commands"]:
        template_file = api_path / f"{category}.html"
        if template_file.exists():
            generate_html(types, category, str(template_file), str(template_file))
        else:
            print(f"Warning: Template file not found: {template_file}")


if __name__ == "__main__":
    main()
